---
title: "Markdown"
author: "El Paso Team"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load-data, include=FALSE, warning=FALSE}

# Load required libraries
library(sf)
library(dplyr)
library(lubridate)
library(tidyverse)
library(data.table)

# -------------------------------
# 1. Foot Traffic Data
# -------------------------------

foot_traffic_file <- "/Users/macytrout/Desktop/El Paso Parking Data/Mobility Data Cincinnati Area Businesses/Home Locations-DESKTOP-MO52HOV.csv"
foot_traffic_df <- read_csv(foot_traffic_file)
# Check the data
head(foot_traffic_df)

# -------------------------------
# 2. 12-Month Occupancy Data
# -------------------------------
occupancy_file <- "data/12_months.csv"
occupancy_12month_df <- read_csv(occupancy_file)
# Check the data
head(occupancy_12month_df)

# -------------------------------
# 3. PEM Transactions Data
# -------------------------------
pems_file1 <- "data/pems transactions jan-jun2024.csv"
pems_file2 <- "data/pems transactions jul-dec2024.csv"
pems_transactions_df <- rbind(
  fread(pems_file1),
  fread(pems_file2)
)
# Optional: Remove erroneous rows if needed
pems_transactions_df <- pems_transactions_df %>% filter(row_number() != 839435)
# Check the data
head(pems_transactions_df)

# -------------------------------
# 4. Streets Data (EPCenterline.geojson)
# -------------------------------
streets_geojson_path <- "data/EPCenterline.geojson"
streets_sf <- st_read(streets_geojson_path) %>%
  rename(street.ID = "OBJECTID_1")
# Check the data
print(streets_sf)

# -------------------------------
# 5. Meters Data (meters.geojson)
# -------------------------------
meters_geojson_path <- "data/meters.geojson"
meters_sf <- st_read(meters_geojson_path)
# Check the data
print(meters_sf)

```


```{r}

# 1. Convert datetime and extract date/time columns
transactions_date_df <- pems_transactions_2024 %>%
  mutate(
    # Convert 'datetime' column to a proper datetime object
    datetime_parsed = mdy_hm(datetime),
    # Separate date and time
    date_only = format(datetime_parsed, "%m/%d/%Y"),
    time_only = format(datetime_parsed, "%H:%M")
  )

# 2. Calculate average minutes paid per weekday (excluding Sunday)
avg_min_per_dayweek <- pems_transactions_2024 %>%
  group_by(dayweek) %>%
  summarise(
    total_min = sum(min_paid, na.rm = TRUE),
    unique_days = n_distinct(date)
  ) %>%
  mutate(
    # Round average minutes per unique day
    avg_min_per_day = round(total_min / unique_days),
    # Factor dayweek in a logical order
    dayweek = factor(dayweek, levels = c(
      "Monday", "Tuesday", "Wednesday", "Thursday",
      "Friday", "Saturday", "Sunday"
    ))
  ) %>%
  arrange(dayweek) %>%
  # Optional: Exclude Sunday if desired
  filter(dayweek != "Sunday") %>%
  # Add a day category (Weekday vs. Weekend)
  mutate(day_category = case_when(
    dayweek %in% c("Monday", "Tuesday", "Wednesday", "Thursday") ~ "Weekday",
    dayweek %in% c("Friday", "Saturday") ~ "Weekend"
  ))

# Check the final data frames
head(transactions_date_df)
head(avg_min_per_dayweek)

```

```{r cluster-functions}
# Prepares data for clustering operation
prepare.clustering.data <- function(data, streets.sf) {
  # Get distinct streets
  streets <- data %>% 
    filter(!is.na(street.ID)) %>%
    distinct(street.ID) %>%
    arrange(street.ID)
  
  # Join to streets.sf to get geom data
  street.centres <- streets.sf %>% 
    right_join(streets) %>%
    st_centroid() %>%
    st_coordinates()
  
  # Join street centres back
  streets$lon = street.centres[,1]
  streets$lat = street.centres[,2]
  
  streets <- streets %>%
    mutate(lon = (lon - mean(lon)) / sd(lon),
           lat = (lat - mean(lat)) / sd(lat))
  
  for (dotw.iter in min(wday(data$timestamp)):max(wday(data$timestamp))) {
    for(hour.iter in min(data$hour):max(data$hour)) {
      streets[[paste0('dotw_',dotw.iter, '_hr_', hour.iter)]] <- data %>%
        filter(hour == hour.iter & wday(timestamp) == dotw.iter) %>%
        group_by(street.ID) %>%
        summarise(value = mean(occupied_fraction_99)) %>%
        arrange(street.ID) %>%
        pull(value)
    }
  }

  
  return(streets)
}


# Normalize and scale coordinates. Then perform k means.
# geographic inflation factor (gif): represents how much importance geography is to clustering 
kmeans_streets <- function(clustering.data, k, gif = 1, streets.sf = NA, seed = NA) {
  
  if (is.numeric(seed)) {
    set.seed(seed)
  }
  
  clustering.data <- clustering.data %>%
    mutate(lon = gif * lon,
           lat = gif * lat)
  
  # Perform k means and assign clusters
  clustering.data$cluster <- factor(kmeans(clustering.data %>% select(-street.ID), k)$cluster)
  
  p <- NA
  
  if (!is.null(dim(streets.sf))) {
    clustering.data.sf <- streets.sf %>% 
      right_join(clustering.data)
    
    p <- ggplot() + 
      geom_sf(data = clustering.data.sf, aes(color = cluster)) + 
      scale_color_manual(values = COLOUR.VEC) +
      theme_void()
    
    print(p)
  }
  
  
  return(clustering.data)
}


plot.cluster.patterns <- function(data.clustered, input.dotw) {
  
  cluster.grouped <- data.clustered %>% 
    mutate(dotw = wday(timestamp)) %>%
    group_by(hour, street.ID, dotw, cluster)
  
  plot.day <- case_when(
    input.dotw == 1 ~ "Sunday",
    input.dotw == 2 ~ "Monday",
    input.dotw == 3 ~ "Tuesday",
    input.dotw == 4 ~ "Wednesday",
    input.dotw == 5 ~ "Thursday",
    input.dotw == 6 ~ "Friday",
    input.dotw == 7 ~ "Saturday",
    T ~ "Unknown")
  
  p <- ggplot(data = cluster.grouped %>%
                filter(dotw == input.dotw) %>%
                summarise(occupied_fraction = mean(occupied_fraction_95))) +
    geom_line(aes(x = hour, 
                  y = occupied_fraction, 
                  group = street.ID, 
                  color = cluster)) +
    scale_color_manual(values = COLOUR.VEC) + 
    geom_line(data = cluster.grouped %>%
                group_by(hour, dotw, cluster) %>%
                filter(dotw == input.dotw) %>%
                summarise(occupied_fraction = mean(occupied_fraction_95)),
              aes(x = hour, y = occupied_fraction), color = "black", size = 1.8) + 
    geom_vline(xintercept = 18, linetype="dashed") + 
    facet_wrap(~cluster, nrow = 2) + 
    ylim(0,1) + 
    labs(y = "Average Street Occupancy", 
         title = paste("Average Street Occupancy Patterns on", plot.day))
  
  print(p)
}

```

```{r cluster-preperation}

occupancy_12month_df_cleaned <- occupancy_12month_df %>%
  mutate(date = date(occupancy.buckets),
         hour = hour(ymd_hms(occupancy.buckets, quiet = F)),
         minute = minute(ymd_hms(occupancy.buckets, quiet = F)),
         hour = replace_na(hour, 0),
         minute = replace_na(minute, 0),
         timestamp = date + hours(hour) + minutes(minute)) %>% 
  filter(!is.na(street.ID)) %>%
  filter(wday(timestamp) != 1) %>%
  filter(street.ID != 24507)

occupancy_12month_df_filtered <- occupancy_12month_df_cleaned %>%
  filter(hour >= 8 & hour < 18)

COLOUR.VEC <- c('#e41a1c',
  '#377eb8',
  '#4daf4a',
  '#984ea3',
  '#ff7f00',
  '#f781bf',
  '#a65628',
  '#999999')

# Prepare data for clustering
clustering.data <- prepare.clustering.data(occupancy_12month_df_filtered,
                                           streets_sf)

clustered <- kmeans_streets(clustering.data, 8, gif = 4, seed=521)

clustering_sf <- streets_sf %>% 
      right_join(clustered)

ggplot() + 
  geom_sf(data = clustering_sf, aes(color = cluster), linewidth = 1) + 
  scale_color_manual(values = COLOUR.VEC) +
  theme_void()
    
```
```{r cluster-patterns-weekday}
# Join cluster information back onto data
data.clustered <- occupancy_12month_df_cleaned %>% 
  filter(!is.na(street.ID)) %>%
  left_join(clustered %>% dplyr::select(street.ID, cluster))

# Plot out the occupancy pattern over a particular day across clusters
plot.cluster.patterns(data.clustered, 5)
```

```{r cluster-patterns-weekend}
# Plot out the occupancy pattern over a particular day across clusters
plot.cluster.patterns(data.clustered, 7)
```
```{r metric-test}

# Compute some metrics at a street level
metrics <- data.clustered %>%
  filter(hour >= 9 & hour <17 & wday(timestamp) != 1) %>%
  group_by(street.ID, cluster) %>%
  summarise(bucket = n(),
            total_toc = sum(occupied_fraction_95 > 0.7),
            total_twc = sum(occupied_fraction_95 < 0.7 & 
                              occupied_fraction_95 > 0.3),
            toc = round(total_toc / bucket,2),
            twc = round(total_twc / bucket,2),
            ave_occupancy = round(mean(occupied_fraction_95),2)) %>%
  dplyr::select(-bucket, -total_toc, -total_twc)

function_line <- function(custom_fun, xmin = 0, xmax = 1){
  x.data <- seq(xmin, xmax, length.out = 100)
  out <- data.frame(x = x.data,
                    y = custom_fun(x.data))
  return(
    geom_line(data = out, aes(x = x, y = y))
  )
}

ggplot(data = metrics) + 
  geom_point(aes(x = ave_occupancy, y = toc)) +
  function_line(function(x) x^1.9)

```
```{r decision-metrics}

cluster.metrics <- data.clustered %>%
  filter(hour >= 9 & hour <17 & wday(timestamp) != 1) %>%
  group_by(cluster) %>%
  summarise(bucket = n(),
            total_toc = sum(occupied_fraction_95 > 0.7),
            total_twc = sum(occupied_fraction_95 < 0.7 & 
                              occupied_fraction_95 > 0.3),
            toc = round(total_toc / bucket,2),
            twc = round(total_twc / bucket,2),
            ave_occupancy = round(mean(occupied_fraction_95),2)) %>%
  dplyr::select(-bucket, -total_toc, -total_twc)


cluster.metrics
```

